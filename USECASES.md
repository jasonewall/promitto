# Use Cases

This document describes the situations in which you'd want to use specific `promitto` functions.

## First: The Entry Point Functions

Designed to be the usual go-tos (no pun intended) when needing to mock a promise for tests.

`promitto<T>()` and `promitto.pending(value: T)` both return a perpetually pending promise that will not resolve until one of their resolver functions are called. This would be useful for validating loading state, or testing that other actions/side effects do not fire until a promise is resolved.

`promitto.resolve` and `promitto.reject` exist as drop-in replacements for `Promise.resolve` and `Promise.reject`. This is functionally different than the other methods as they do not return a pending promise, but an immediately resolved promise. You would want to use the Promitto pre-resolved methods in your test cases to allow the application to build promise mocks instead of async promises. Our tests then have access to the entirety of the chain (via the [`#children` property](#children) of all PromiseMocks). This becomes more relevant as we understand the purpose of the [`#settled`](#settled) method.

## The Instance Methods

### `children`

All promise mocks track the promises created from calling their `then`, `catch`, `finally` methods. While this is only done for the sake of the `settled()` function, it is also exposed for troubleshooting purposes. This attribute could be logged out to get some clues as to the shape of our promise chain.

It is NOT recommended that you make assertions based on the contents of children.

### `settled()`

While the implementation of all promise mocks in `promitto` are entirely synchronous the Promise spec behaves in such a way that fulfillment handlers (callbacks passed as the first argument of `then`) and rejection handlers (callbacks passed into `catch` or as the second argument of `then`) can resolve to `PromiseLike<Return Type>`. This means that application code or any other package in our applications could add asynchronous promises to our chain. Because of this all PromiseMock types have a `settled()` method that returns a core Promise which will only resolve once the entire chain is settled.

Keep in mind when we inject Promises into our application in unit tests we typically can just test a promise returned by our application code and `await` that.

```ts
const p = callMyApplication(promitto.resolve("A value to respresent success."));

const result = await p;

// assert result is as expected
```

If the code we are trying to test cannot return the end of the chain (e.g. timers, intervals, debounces) we have a few options that typically involve manipulating the promise job queue with something like `await Promise.resolve()`/`await new Promise(process.nextTick)`/`await new Promise(setImmediate)`. All of these approaches either do not work consistently or do not work on all platforms. `#settled()` provides a consistent method to wait for all relevant work to finish before making assertions.

```ts
const p = promitto.resolve("A value to represent success.");
const apiSpy = testingFramework.spyOn(myApi, "getData").mockReturnValue(p);

callApplication();

await p.settled();

// assert application state after promise has settled
```

NOTE: The promise returned by `settled()` is NOT tracked in `children`. This is intentional so they are an accurate representation of the promise chain generated by our application.

### Settling Rejected PromiseMocks

The `settled()` promise always resolves to the same state as our head promise, so rejected heads should be caught by the standard approach of your testing framework.

e.g. In jest:

```ts
const p = promitto.reject(new Error("Something went wrong."));

callMyApplicationThatShouldCatch(p);

await expect(p.settled()).rejects.toThrowError();

// add expectations that verify application state
```
